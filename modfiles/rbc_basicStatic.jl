module rbc_basicStatic
#
# NB: this file was automatically generated by Dynare
#     from rbc_basic.mod
#
using StatsFuns

export tmp_nbr, static!, staticResid!, staticG1!, staticG2!, staticG3!

#=
# The comments below apply to all functions contained in this module #
  NB: The arguments contained on the first line of the function
      definition are those that are modified in place

## Exported Functions ##
  static!      : Wrapper function; computes residuals, Jacobian, Hessian,
                 and third order derivatives matroces depending on the arguments provided
  staticResid! : Computes the static model residuals
  staticG1!    : Computes the static model Jacobian
  staticG2!    : Computes the static model Hessian
  staticG3!    : Computes the static model third derivatives

## Exported Variables ##
  tmp_nbr      : Vector{Int}(4) respectively the number of temporary variables
                 for the residuals, g1, g2 and g3.

## Local Functions ##
  staticResidTT! : Computes the static model temporary terms for the residuals
  staticG1TT!    : Computes the static model temporary terms for the Jacobian
  staticG2TT!    : Computes the static model temporary terms for the Hessian
  staticG3TT!    : Computes the static model temporary terms for the third derivatives

## Function Arguments ##
  T        : Vector{Float64}(num_temp_terms) temporary terms
  y        : Vector{Float64}(model_.endo_nbr) endogenous variables in declaration order
  x        : Vector{Float64}(model_.exo_nbr) exogenous variables in declaration order
  params   : Vector{Float64}(model_.param) parameter values in declaration order
  residual : Vector{Float64}(model_.eq_nbr) residuals of the static model equations
             in order of declaration of the equations. Dynare may prepend auxiliary equations,
             see model.aux_vars
  g1       : Matrix{Float64}(model.eq_nbr,model_.endo_nbr) Jacobian matrix of the static model equations
             The columns and rows respectively correspond to the variables in declaration order and the
             equations in order of declaration
  g2       : spzeros(model.eq_nbr, model_.endo^2) Hessian matrix of the static model equations
             The columns and rows respectively correspond to the variables in declaration order and the
             equations in order of declaration
  g3       : spzeros(model.eq_nbr, model_.endo^3) Third order derivatives matrix of the static model equations
             The columns and rows respectively correspond to the variables in declaration order and the
             equations in order of declaration

## Remarks ##
  [1] The size of `T`, ie the value of `num_temp_terms`, depends on the version of the static model called. The number of temporary variables
      used for the different returned objects (residuals, jacobian, hessian or third order derivatives) is given by the elements in `tmp_nbr`
      exported vector. The first element is the number of temporaries used for the computation of the residuals, the second element is the
      number of temporaries used for the evaluation of the jacobian matrix, etc. If one calls the version of the static model computing the
      residuals, and the jacobian and hessian matrices, then `T` must have at least `sum(tmp_nbr[1:3])` elements.
=#

tmp_nbr = zeros(Int,4)
tmp_nbr[1] = 6# Number of temporary terms for the residuals
tmp_nbr[2] = 2# Number of temporary terms for g1 (jacobian)
tmp_nbr[3] = 0# Number of temporary terms for g2 (hessian)
tmp_nbr[4] = 0# Number of temporary terms for g3 (third order derivates)

function staticResidTT!(T::Vector{Float64},
                        y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64})
    @assert length(T) >= 6
    @inbounds T[1] = 1/y[2]*params[1]
    @inbounds T[2] = params[3]*exp(y[6])*y[3]^(params[3]-1)
    @inbounds T[3] = y[5]^(1-params[3])
    @inbounds T[4] = T[2]*T[3]+1-params[2]
    @inbounds T[5] = y[3]^params[3]
    @inbounds T[6] = y[5]^(-params[3])
    return nothing
end

function staticResid!(T::Vector{Float64}, residual::Vector{Float64},
                      y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T0_flag::Bool)
    @assert length(y) == 6
    @assert length(x) == 1
    @assert length(params) == 6
    @assert length(residual) == 6
    if T0_flag
        staticResidTT!(T, y, x, params)
    end
    @inbounds residual[1] = (1/y[2]) - (T[1]*T[4])
    @inbounds residual[2] = (y[2]*params[6]/(1-y[5])) - (exp(y[6])*(1-params[3])*T[5]*T[6])
    @inbounds residual[3] = (y[2]+y[3]-y[3]*(1-params[2])) - (T[3]*exp(y[6])*T[5])
    @inbounds residual[4] = (y[1]) - (T[3]*exp(y[6])*T[5])
    @inbounds residual[5] = (y[4]) - (y[1]-y[2])
    @inbounds residual[6] = (y[6]) - (y[6]*params[4]+x[1])
    if ~isreal(residual)
        residual = real(residual)+imag(residual).^2;
    end
    return nothing
end

function staticG1TT!(T::Vector{Float64},
                     y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T0_flag::Bool)
    if T0_flag
        staticResidTT!(T, y, x, params)
    end
    @inbounds T[7] = get_power_deriv(y[3],params[3],1)
    @inbounds T[8] = get_power_deriv(y[5],1-params[3],1)
    return nothing
end

function staticG1!(T::Vector{Float64}, g1::Matrix{Float64},
                   y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T1_flag::Bool, T0_flag::Bool)
    @assert length(T) >= 8
    @assert size(g1) == (6, 6)
    @assert length(y) == 6
    @assert length(x) == 1
    @assert length(params) == 6
    if T1_flag
        staticG1TT!(T, y, x, params, T0_flag)
    end
    fill!(g1, 0.0)
    @inbounds g1[1,2]=(-1)/(y[2]*y[2])-T[4]*params[1]*(-1)/(y[2]*y[2]);
    @inbounds g1[1,3]=(-(T[1]*T[3]*params[3]*exp(y[6])*get_power_deriv(y[3],params[3]-1,1)));
    @inbounds g1[1,5]=(-(T[1]*T[2]*T[8]));
    @inbounds g1[1,6]=(-(T[1]*T[2]*T[3]));
    @inbounds g1[2,2]=params[6]/(1-y[5]);
    @inbounds g1[2,3]=(-(T[6]*exp(y[6])*(1-params[3])*T[7]));
    @inbounds g1[2,5]=y[2]*params[6]/((1-y[5])*(1-y[5]))-exp(y[6])*(1-params[3])*T[5]*get_power_deriv(y[5],(-params[3]),1);
    @inbounds g1[2,6]=(-(exp(y[6])*(1-params[3])*T[5]*T[6]));
    @inbounds g1[3,2]=1;
    @inbounds g1[3,3]=1-(1-params[2])-T[3]*exp(y[6])*T[7];
    @inbounds g1[3,5]=(-(exp(y[6])*T[5]*T[8]));
    @inbounds g1[3,6]=(-(T[3]*exp(y[6])*T[5]));
    @inbounds g1[4,1]=1;
    @inbounds g1[4,3]=(-(T[3]*exp(y[6])*T[7]));
    @inbounds g1[4,5]=(-(exp(y[6])*T[5]*T[8]));
    @inbounds g1[4,6]=(-(T[3]*exp(y[6])*T[5]));
    @inbounds g1[5,1]=(-1);
    @inbounds g1[5,2]=1;
    @inbounds g1[5,4]=1;
    @inbounds g1[6,6]=1-params[4];
    if ~isreal(g1)
        g1 = real(g1)+2*imag(g1);
    end
    return nothing
end

function staticG2TT!(T::Vector{Float64},
                     y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T1_flag::Bool, T0_flag::Bool)
    if T1_flag
        staticG1TT!(T, y, x, params, TO_flag)
    end
    return nothing
end

function staticG2!(T::Vector{Float64}, g2::Matrix{Float64},
                   y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T2_flag::Bool, T1_flag::Bool, T0_flag::Bool)
    @assert length(T) >= 8
    @assert size(g2) == (6, 36)
    @assert length(y) == 6
    @assert length(x) == 1
    @assert length(params) == 6
    if T2_flag
        staticG2TT!(T, y, x, params, T1_flag, T0_flag)
    end
    fill!(g2, 0.0)
    return nothing
end

function staticG3TT!(T::Vector{Float64},
                     y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T2_flag::Bool, T1_flag::Bool, T0_flag::Bool)
    if T2_flag
        staticG2TT!(T, y, x, params, T1_flag, T0_flag)
    end
    return nothing
end

function staticG3!(T::Vector{Float64}, g3::Matrix{Float64},
                   y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64}, T3_flag::Bool, T2_flag::Bool, T1_flag::Bool, T0_flag::Bool)
    @assert length(T) >= 8
    @assert size(g3) == (6, 216)
    @assert length(y) == 6
    @assert length(x) == 1
    @assert length(params) == 6
    if T3_flag
        staticG3TT!(T, y, x, params, T2_flag, T1_flag, T0_flag)
    end
    fill!(g3, 0.0)
    return nothing
end

function static!(T::Vector{Float64}, residual::Vector{Float64},
                  y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64})
    staticResid!(T, residual, y, x, params, true)
    return nothing
end

function static!(T::Vector{Float64}, residual::Vector{Float64}, g1::Matrix{Float64},
                 y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64})
    staticG1!(T, g1, y, x, params, true, true)
    staticResid!(T, residual, y, x, params, false)
    return nothing
end

function static!(T::Vector{Float64}, g1::Matrix{Float64},
                 y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64})
    staticG1!(T, g1, y, x, params, true, false)
    return nothing
end

function static!(T::Vector{Float64}, residual::Vector{Float64}, g1::Matrix{Float64}, g2::Matrix{Float64},
                 y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64})
    staticG2!(T, g2, y, x, params, true, true, true)
    staticG1!(T, g1, y, x, params, false, false)
    staticResid!(T, residual, y, x, params, false)
    return nothing
end

nearbyint(x::Float64) = (abs((x)-floor(x)) < abs((x)-ceil(x)) ? floor(x) : ceil(x))

function get_power_deriv(x::Float64, p::Float64, k::Int64)
    if (abs(x) < 1e-12 && p > 0 && k > p && abs(p-nearbyint(p)) < 1e-12 )
        return 0.0
    else
        dxp = x^(p-k)
        for i = 1:k
	     dxp *= p
	     p -= 1
	 end
	 return dxp
    end
end
end
