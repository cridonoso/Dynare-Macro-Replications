module rbc_basicDynamic
#
# NB: this file was automatically generated by Dynare
#     from rbc_basic.mod
#
using StatsFuns

export tmp_nbr, dynamic!, dynamicResid!, dynamicG1!, dynamicG2!, dynamicG3!

#=
# The comments below apply to all functions contained in this module #
  NB: The arguments contained on the first line of the function
      definition are those that are modified in place

## Exported Functions ##
  dynamic!      : Wrapper function; computes residuals, Jacobian, Hessian,
                  and third derivatives depending on the arguments provided
  dynamicResid! : Computes the dynamic model residuals
  dynamicG1!    : Computes the dynamic model Jacobian
  dynamicG2!    : Computes the dynamic model Hessian
  dynamicG3!    : Computes the dynamic model third derivatives

## Exported Variables ##
  tmp_nbr       : Vector{Int}(4) respectively the number of temporary variables
                  for the residuals, g1, g2 and g3.

## Local Functions ##
  dynamicResidTT! : Computes the dynamic model temporary terms for the residuals
  dynamicG1TT!    : Computes the dynamic model temporary terms for the Jacobian
  dynamicG2TT!    : Computes the dynamic model temporary terms for the Hessian
  dynamicG3TT!    : Computes the dynamic model temporary terms for the third derivatives

## Function Arguments ##
  T            : Vector{Float64}(num_temp_terms), temporary terms
  y            : Vector{Float64}(num_dynamic_vars), endogenous variables in the order stored model_.lead_lag_incidence; see the manual
  x            : Matrix{Float64}(nperiods,model_.exo_nbr), exogenous variables (in declaration order) for all simulation periods
  params       : Vector{Float64}(model_.param_nbr), parameter values in declaration order
  steady_state : Vector{Float64}(model_endo_nbr)
  it_          : Int, time period for exogenous variables for which to evaluate the model
  residual     : Vector{Float64}(model_.eq_nbr), residuals of the dynamic model equations in order of declaration of the equations.
  g1           : Matrix{Float64}(model_.eq_nbr, num_dynamic_vars), Jacobian matrix of the dynamic model equations
                 The rows and columns respectively correspond to equations in order of declaration and variables in order
                 stored in model_.lead_lag_incidence
  g2           : spzeros(model_.eq_nbr, (num_dynamic_vars)^2) Hessian matrix of the dynamic model equations
                 The rows and columns respectively correspond to equations in order of declaration and variables in order
                 stored in model_.lead_lag_incidence
  g3           : spzeros(model_.eq_nbr, (num_dynamic_vars)^3) Third order derivative matrix of the dynamic model equations;
                 The rows and columns respectively correspond to equations in order of declaration and variables in order
                 stored in model_.lead_lag_incidence

## Remarks ##
  [1] `num_dynamic_vars` is the number of non zero entries in the lead lag incidence matrix, `model_.lead_lag_incidence.`
  [2] The size of `T`, ie the value of `num_temp_terms`, depends on the version of the dynamic model called. The number of temporary variables
      used for the different returned objects (residuals, jacobian, hessian or third order derivatives) is given by the elements in `tmp_nbr`
      exported vector. The first element is the number of temporaries used for the computation of the residuals, the second element is the
      number of temporaries used for the evaluation of the jacobian matrix, etc. If one calls the version of the dynamic model computing the
      residuals, the jacobian and hessian matrices, then `T` must have at least `sum(tmp_nbr[1:3])` elements.
=#

tmp_nbr = zeros(Int,4)
tmp_nbr[1] = 8# Number of temporary terms for the residuals
tmp_nbr[2] = 2# Number of temporary terms for g1 (jacobian)
tmp_nbr[3] = 0# Number of temporary terms for g2 (hessian)
tmp_nbr[4] = 0# Number of temporary terms for g3 (third order derivates)

function dynamicResidTT!(T::Vector{Float64},
                         y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    @inbounds T[1] = params[1]*1/y[9]
    @inbounds T[2] = params[3]*exp(y[11])*y[5]^(params[3]-1)
    @inbounds T[3] = y[10]^(1-params[3])
    @inbounds T[4] = T[2]*T[3]+1-params[2]
    @inbounds T[5] = y[1]^params[3]
    @inbounds T[6] = y[7]^(-params[3])
    @inbounds T[7] = y[7]^(1-params[3])
    @inbounds T[8] = exp(y[8])*T[5]*T[7]
    return nothing
end

function dynamicResid!(T::Vector{Float64}, residual::AbstractVector{Float64},
                       y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int, T_flag::Bool)
    @assert length(T) >= 8
    @assert length(residual) == 6
    @assert length(y)+size(x, 2) == 12
    @assert length(params) == 6
    if T_flag
        dynamicResidTT!(T, y, x, params, steady_state, it_)
    end
    @inbounds residual[1] = (1/y[4]) - (T[1]*T[4])
    @inbounds residual[2] = (y[4]*params[6]/(1-y[7])) - ((1-params[3])*exp(y[8])*T[5]*T[6])
    @inbounds residual[3] = (y[4]+y[5]-(1-params[2])*y[1]) - (T[8])
    @inbounds residual[4] = (y[3]) - (T[8])
    @inbounds residual[5] = (y[6]) - (y[3]-y[4])
    @inbounds residual[6] = (y[8]) - (params[4]*y[2]+x[it_, 1])
    return nothing
end

function dynamicG1TT!(T::Vector{Float64},
                      y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicResidTT!(T, y, x, params, steady_state, it_)
    @inbounds T[9] = get_power_deriv(y[1],params[3],1)
    @inbounds T[10] = (-(exp(y[8])*T[5]*get_power_deriv(y[7],1-params[3],1)))
    return nothing
end

function dynamicG1!(T::Vector{Float64}, g1::Matrix{Float64},
                    y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int, T_flag::Bool)
    @assert length(T) >= 10
    @assert size(g1) == (6, 12)
    @assert length(y)+size(x, 2) == 12
    @assert length(params) == 6
    if T_flag
        dynamicG1TT!(T, y, x, params, steady_state, it_)
    end
    fill!(g1, 0.0)
    @inbounds g1[1,4]=(-1)/(y[4]*y[4]);
    @inbounds g1[1,9]=(-(T[4]*params[1]*(-1)/(y[9]*y[9])));
    @inbounds g1[1,5]=(-(T[1]*T[3]*params[3]*exp(y[11])*get_power_deriv(y[5],params[3]-1,1)));
    @inbounds g1[1,10]=(-(T[1]*T[2]*get_power_deriv(y[10],1-params[3],1)));
    @inbounds g1[1,11]=(-(T[1]*T[2]*T[3]));
    @inbounds g1[2,4]=params[6]/(1-y[7]);
    @inbounds g1[2,1]=(-(T[6]*(1-params[3])*exp(y[8])*T[9]));
    @inbounds g1[2,7]=y[4]*params[6]/((1-y[7])*(1-y[7]))-(1-params[3])*exp(y[8])*T[5]*get_power_deriv(y[7],(-params[3]),1);
    @inbounds g1[2,8]=(-((1-params[3])*exp(y[8])*T[5]*T[6]));
    @inbounds g1[3,4]=1;
    @inbounds g1[3,1]=(-(1-params[2]))-T[7]*exp(y[8])*T[9];
    @inbounds g1[3,5]=1;
    @inbounds g1[3,7]=T[10];
    @inbounds g1[3,8]=(-T[8]);
    @inbounds g1[4,3]=1;
    @inbounds g1[4,1]=(-(T[7]*exp(y[8])*T[9]));
    @inbounds g1[4,7]=T[10];
    @inbounds g1[4,8]=(-T[8]);
    @inbounds g1[5,3]=(-1);
    @inbounds g1[5,4]=1;
    @inbounds g1[5,6]=1;
    @inbounds g1[6,2]=(-params[4]);
    @inbounds g1[6,8]=1;
    @inbounds g1[6,12]=(-1);
    return nothing
end

function dynamicG2TT!(T::Vector{Float64},
                      y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicG1TT!(T, y, x, params, steady_state, it_)
    return nothing
end

function dynamicG2!(T::Vector{Float64}, g2::Matrix{Float64},
                    y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int, T_flag::Bool)
    @assert length(T) >= 10
    @assert size(g2) == (6, 144)
    @assert length(y)+size(x, 2) == 12
    @assert length(params) == 6
    if T_flag
        dynamicG2TT!(T, y, x, params, steady_state, it_)
    end
    fill!(g2, 0.0)
    return nothing
end

function dynamicG3TT!(T::Vector{Float64},
                      y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicG2TT!(T, y, x, params, steady_state, it_)
    return nothing
end

function dynamicG3!(T::Vector{Float64}, g3::Matrix{Float64},
                    y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int, T_flag::Bool)
    @assert length(T) >= 10
    @assert size(g3) == (6, 1728)
    @assert length(y)+size(x, 2) == 12
    @assert length(params) == 6
    if T_flag
      dynamicG3TT!(T, y, x, params, steady_state, it_)
    end
    fill!(g3, 0.0)
    return nothing
end

function dynamic!(T::Vector{Float64}, residual::AbstractVector{Float64},
                  y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicResid!(T, residual, y, x, params, steady_state, it_, true)
    return nothing
end

function dynamic!(T::Vector{Float64}, residual::AbstractVector{Float64}, g1::Matrix{Float64},
                  y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicG1!(T, g1, y, x, params, steady_state, it_, true)
    dynamicResid!(T, residual, y, x, params, steady_state, it_, false)
    return nothing
end

function dynamic!(T::Vector{Float64}, residual::AbstractVector{Float64}, g1::Matrix{Float64}, g2::Matrix{Float64},
                  y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicG2!(T, g2, y, x, params, steady_state, it_, true)
    dynamicG1!(T, g1, y, x, params, steady_state, it_, false)
    dynamicResid!(T, residual, y, x, params, steady_state, it_, false)
    return nothing
end

function dynamic!(T::Vector{Float64}, residual::AbstractVector{Float64}, g1::Matrix{Float64}, g2::Matrix{Float64}, g3::Matrix{Float64},
                  y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64}, steady_state::Vector{Float64}, it_::Int)
    dynamicG3!(T, g3, y, x, params, steady_state, it_, true)
    dynamicG2!(T, g2, y, x, params, steady_state, it_, false)
    dynamicG1!(T, g1, y, x, params, steady_state, it_, false)
    dynamicResid!(T, residual, y, x, params, steady_state, it_, false)
    return nothing
end

nearbyint(x::Float64) = (abs((x)-floor(x)) < abs((x)-ceil(x)) ? floor(x) : ceil(x))

function get_power_deriv(x::Float64, p::Float64, k::Int64)
    if (abs(x) < 1e-12 && p > 0 && k > p && abs(p-nearbyint(p)) < 1e-12 )
        return 0.0
    else
        dxp = x^(p-k)
        for i = 1:k
	     dxp *= p
	     p -= 1
	 end
	 return dxp
    end
end
end
